# Vix语言数组操作原地修改更新说明

## 更新概述

在本次更新中，我们对Vix语言的数组操作进行了改进，使得所有数组操作都支持原地修改（in-place modification）。这意味着所有数组操作都会直接修改原始数组，而不是创建新数组或返回修改后的新数组。

## 修改的操作

### 1. `push` 操作

- **之前**: `arr.push(value)` 会创建一个包含原数组元素和新元素的新数组
- **现在**: `arr.push(value)` 直接向原数组末尾添加元素，原地修改数组
- **示例**:
  ```vix
  arr = ["A", "B"]
  arr.push("C")  // 现在直接修改原数组
  print(arr)     // 输出: ["A", "B", "C"]
  ```

### 2. `remove!` 操作（新增）

- **功能**: 从数组中移除指定索引的元素，直接修改原数组
- **区别**: 与 `remove` 操作不同，`remove!` 不返回被移除的元素
- **示例**:
  ```vix
  arr = ["A", "B", "C"]
  arr.remove!(1)  // 移除索引1的元素，直接修改原数组
  print(arr)      // 输出: ["A", "C"]
  ```

### 3. `pop!` 操作（新增）

- **功能**: 弹出数组最后一个元素，直接修改原数组
- **区别**: 与 `pop` 操作不同，`pop!` 不返回被弹出的元素
- **示例**:
  ```vix
  arr = ["A", "B", "C"]
  arr.pop!()      // 弹出最后一个元素，直接修改原数组
  print(arr)      // 输出: ["A", "B"]
  ```

## 保留的操作

### 1. `add!` 操作

- **功能**: 在指定索引处添加元素，直接修改原数组
- **示例**:
  ```vix
  arr = ["A", "C"]
  arr.add!(1, "B")  // 在索引1处添加"B"，直接修改原数组
  print(arr)        // 输出: ["A", "B", "C"]
  ```

### 2. `push!` 操作

- **功能**: 在数组末尾添加元素，直接修改原数组
- **示例**:
  ```vix
  arr = ["A", "B"]
  arr.push!("C")  // 在末尾添加"C"，直接修改原数组
  print(arr)      // 输出: ["A", "B", "C"]
  ```

### 3. `replace!` 操作

- **功能**: 替换指定索引的元素，直接修改原数组
- **示例**:
  ```vix
  arr = ["A", "B", "C"]
  arr.replace!(1, "X")  // 将索引1的元素替换为"X"，直接修改原数组
  print(arr)            // 输出: ["A", "X", "C"]
  ```

### 4. `remove` 操作

- **功能**: 从数组中移除指定索引的元素，返回被移除的元素
- **注意**: 数组本身也会被修改
- **示例**:
  ```vix
  arr = ["A", "B", "C"]
  removed = arr.remove(1)  // 移除索引1的元素并返回它
  print(removed)           // 输出: B
  print(arr)               // 输出: ["A", "C"]
  ```

### 5. `pop` 操作

- **功能**: 弹出数组最后一个元素，返回被弹出的元素
- **注意**: 数组本身也会被修改
- **示例**:
  ```vix
  arr = ["A", "B", "C"]
  last = arr.pop()  // 弹出最后一个元素并返回它
  print(last)       // 输出: C
  print(arr)        // 输出: ["A", "B"]
  ```

## 设计规范

根据Vix语言的设计规范，原地修改操作的方法名通常以感叹号(`!`)结尾，如 `add!`, `push!`, `replace!`, `remove!`, `pop!`。

## 测试文件

我们提供了一个测试文件来验证这些修改：
1. `list_op3.vix` - 完整测试，包含各种复杂场景

## 性能影响

由于所有数组操作现在都是原地修改，这减少了不必要的内存分配和数据复制，提高了程序的性能和内存效率。
